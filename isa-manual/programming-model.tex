% -*- mode: latex; tab-width: 2; indent-tabs-mode: nil; -*-
%------------------------------------------------------------------------------
% MRISC32 ISA Manual - Programming model.
%
% This work is licensed under the Creative Commons Attribution-ShareAlike 4.0
% International License. To view a copy of this license, visit
% http://creativecommons.org/licenses/by-sa/4.0/ or send a letter to
% Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
%------------------------------------------------------------------------------

\chapter{Programming model}

\section{Architecture profiles}

\begin{todobox}
Describe the base ISA and extensions, i.e. roughly:

\begin{itemize}
  \item Support for vector operations.
  \item Support for packed operations.
  \item Support for floating-point operations.
  \item Support for saturating and halving arithmetic.
\end{itemize}

We should also define 2-4 profiles that an implementation must comply to (to
minimize fragmentation). This is more to convey the intent of the ISA than
anything else.

We also need to document which instructions are not part of the base ISA,
e.g. by tagging them in the instruction database.
\end{todobox}

\section{Scalar registers}

There are 32 scalar registers, each 32 bits wide.

\begin{bytefield}{32}
  \bitheader{0,31} \\
  \wordbox{1}{Z (S0)} \\
  \wordbox{1}{S1} \\
  \wordbox{1}{S2} \\
  \wordbox[]{1}{$\vdots$} \\[1ex]
  \wordbox{1}{S24} \\
  \wordbox{1}{S25} \\
  \wordbox{1}{FP (S26)} \\
  \wordbox{1}{TP (S27)} \\
  \wordbox{1}{SP (S28)} \\
  \wordbox{1}{VL (S29)} \\
  \wordbox{1}{LR (S30)} \\
  \wordbox{1}{PC (S31)}
\end{bytefield}

\subsection{The Z register}

Z is a read-only register that is always zero. Writing to the Z register has no
effect.

\subsection{The VL register}

VL is the vector length register, which defines the length of vector
operations.

\todo{Describe how the VL register affects vector operations.}

\subsection{The LR register}

LR is the link register, which contains the return address for subroutines.

\subsection{The PC register}

PC is a read-only register that contains the memory address of the current
instruction. Writing to the PC register has no effect.

\subsection{FP, TP and SP}

The scalar registers FP, TP and SP are aliases for S26, S27 and S28,
respectively. They have no special meaning in hardware, but it is recommended
that they are used as follows:

\begin{tabular}{|l|l|}
  \hline
  \textbf{Name} & \textbf{Description} \\
  \hline
  FP & Frame pointer \\
  \hline
  TP & Thread pointer (for thread local storage) \\
  \hline
  SP & Stack pointer \\
  \hline
\end{tabular}

\section{Vector registers}

There are 32 vector registers:

\begin{tabular}{|l|l|}
  \hline
  \textbf{Vector reg. no} & \textbf{Name} \\
  \hline
  0 & VZ \\
  \hline
  1 & V1 \\
  \hline
  2 & V2 \\
  \hline
  3 & V3 \\
  \hline
  4 & V4 \\
  \hline
  \multicolumn{2}{c}{$\vdots$} \\
  \hline
  30 & V30 \\
  \hline
  31 & V31 \\
  \hline
\end{tabular}


Each register, V$k$, consists of $N$ 32-bit elements, where $N$ is
implementation defined ($N$ must be a power of two, and at least 16):

\begin{bytefield}{32}
  \bitheader{0,31} \\
  \wordbox{1}{V$k[0]$} \\
  \wordbox{1}{V$k[1]$} \\
  \wordbox{1}{V$k[2]$} \\
  \wordbox{1}{V$k[3]$} \\
  \wordbox{1}{V$k[4]$} \\
  \wordbox[]{1}{$\vdots$} \\[1ex]
  \wordbox{1}{V$k[N-2]$} \\
  \wordbox{1}{V$k[N-1]$}
\end{bytefield}

\subsection{The VZ register}

VZ is a read-only register with all vector elements set to zero. Writing to the
VZ register has no effect.

\section{Floating-point operation}

The MRISC32 ISA supports a subset of the 2008 IEEE-754 floating-point
standard~\cite{ieee754-2008}.

\tbd

\section{Vector operation}

\begin{todobox}
Describe how vector operations process elements of vector registers.

Describe how VL affects vector operations.

Describe how folding works.
\end{todobox}

\section{Packed data operation}
\label{sec:packed_data_operation}

Many instructions have the ability to operate on several individual sub-parts
of the source and destination elements. These sub-parts are referred to as
chunks.

A single 32-bit element may be split up into one, two or four chunks, as follows:

\begin{bytefield}{32}
  \bitheader{0,8,16,24,31} \\
  \begin{rightwordgroup}{}
    \bitbox{32}{word}
  \end{rightwordgroup} \\
  \begin{rightwordgroup}{H}
    \bitbox{16}{half-word} &
   \bitbox{16}{half-word}
  \end{rightwordgroup} \\
  \begin{rightwordgroup}{B}
    \bitbox{8}{byte} &
    \bitbox{8}{byte} &
    \bitbox{8}{byte} &
    \bitbox{8}{byte}
  \end{rightwordgroup}
\end{bytefield}

\subsection{Word mode}

In word mode, which is the defult, each element is processed as a single
32-bit chunk.

\subsection{Half-word mode}

In half-word mode each element is processed as two individual 16-bit chunks in
parallel.

In assembly language, half-word mode is indicated by appending the suffix .H
to the instruction mnemonic.

\subsection{Byte mode}

In byte mode each element is processed as four individual 8-bit chunks in
parallel.

In assembly language, byte mode is indicated by appending the suffix .B to the
instruction mnemonic.

\subsection{Packed floating-point operation}

For floating-point instructions, using packed operating modes implies using
floating-point precisions lower than single precision:

\begin{tabular}{|l|l|}
  \hline
  \textbf{Mode} & \textbf{Precision} \\
  \hline
  word & Single precision floating-point \\
  \hline
  half-word & Half precision floating-point \\
  \hline
  byte & Quarter precision floating-point \\
  \hline
\end{tabular}

\section{Memory addressing}

\tbd

\section{Exceptions}

\tbd
