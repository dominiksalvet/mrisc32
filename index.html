<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1">
        <title>MRISC32: An open 32-bit RISC/Vector ISA</title>
        <link rel="stylesheet" href="https://mbitsnbites.github.io/css-styles/light-on-gray.css">
        <link rel="stylesheet" href="site.css">
    </head>
    <body>
        <h1>MRISC32: An open 32-bit RISC/Vector ISA</h2>
        <div class="text-section">
            <p>
                MRISC32, short for <i>"<u>M</u>ostly harmless <u>R</u>educed <u>I</u>nstruction <u>S</u>et <u>C</u>omputer, <u>32</u>-bit edition"</i>,
                is a 32-bit RISC/Vector instruction set architecture
                (<a href="https://en.wikipedia.org/wiki/Instruction_set_architecture">ISA</a>).
            </p>
            <p>
                The focus is to create a clean, modern ISA that is equally attractive to software,
                hardware and compiler developers. Another key goal is to enable high performance
                implementations, with good scalar and vector integer, floating point and fixed point
                support.
            </p>
            <p>
                The ISA is primarily inspired by the <a href="https://en.wikipedia.org/wiki/Cray-1">Cray-1</a>
                and <a href="https://en.wikipedia.org/wiki/MIPS_architecture">MIPS</a> architectures,
                and is further influenced by the excellent <a href="https://en.wikipedia.org/wiki/RISC-V">RISC-V</a>
                architecture (in particular "<a href="https://people.eecs.berkeley.edu/~krste/papers/EECS-2016-1.pdf">Design of the RISC-V Instruction Set Architecture</a>"
                by Andrew Waterman).
            </p>
        </div>

        <h2>Features</h2>
        <div class="text-section">
            <ul>
                <li>Unified scalar/vector/integer/floating point ISA</li>
                <li>Load/store architecture</li>
                <li>Two register files:
                    <ul>
                        <li>32 scalar registers</li>
                        <li>32 vector registers</li>
                    </ul>
                </li>
                <li>Fixed size 32 bits wide instruction words:
                    <ul>
                        <li>Easily decoded instructions (only three basic formats)</li>
                        <li>Less than 60% of the avilable instruction space is used, allowing for future extensions</li>
                        <li>Space has been reserved for future multi-word encodings</li>
                    </ul>
                </li>
                <li>Branches are based on register content, not condition codes:
                    <ul>
                        <li>Compare instructions generate bit masks (all 1:s or all 0:s)</li>
                        <li>Branch instructions can act on bit masks and signed quantities</li>
                        <li>Bit masks can further be used for masking and arithmetic</li>
                    </ul>
                </li>
                <li>Supports IEEE 754 floating point</li>
                <li>Supports fixed point operations</li>
                <li>Dynamic and future proof vector model:
                    <ul>
                        <li>Most instructions can operate on both scalar and vector registers</li>
                        <li>Vector operation lengths are variable on a per-instruction basis</li>
                        <li>Each vector register can hold at least 16 32-bit elements</li>
                        <li>Implementers may choose to provide significantly larger registers</li>
                        <li>Software is binary compatible between different vector register sizes</li>
                    </ul>
                </li>
                <li>8-bit and 16-bit data types can be packed in 32-bit chunks:
                    <ul>
                        <li>Most instructions offer increased parallelism for packed data types:
                            <ul>
                                <li>2x parallelism for 16-bit data types</li>
                                <li>4x parallelism for 8-bit data types</li>
                            </ul>
                        </li>
                        <li>Supports packed integer, fixed point and floating point types</li>
                    </ul>
                </li>
                <li>Powerful addressing modes:
                    <ul>
                        <li>Wide range PC-relative and absolute addressing for load/store and branches</li>
                        <li>Gather/scatter and stride-based vector load/store</li>
                        <li>Scaled indexed load/store addressing (register + scale * register)</li>
                    </ul>
                </li>
                <li>Many parts of the ISA are optional:
                    <ul>
                        <li>It is possible to create a very lightweight MRISC32 core</li>
                        <li>Things like floating point, vector operations and hardware division are optional</li>
                    </ul>
                </li>
            </ul>
        </div>

        <h2>Implementations</h2>
        <div class="text-section">
            <h3>MRISC32-A1</h3>
            <p>
                The first implementation of the MRISC32 ISA is <a href="https://github.com/mbitsnbites/mrisc32/tree/master/hw/mrisc32-a1">MRISC32-A1</a>,
                which is a soft processor implemented in portable VHDL, suitable for running
                on an FPGA. It is a single issue, in order architecture (i.e. it can execute
                up to one operation per clock cycle), and it implements the entire MRISC32 ISA.
            </p>
            <p>
                The CPU easily fits in a low- to mid-range FPGA, such as the <a href="https://www.intel.com/content/www/us/en/products/programmable/fpga/cyclone-v.html">Cyclone® V</a>,
                in which it consumes about 5000 ALM:s and runs at around 80 MHz at the
                time of writing. It can also be configured to use much less resources
                (down to 30% of the full design) by disabling certain features, such as
                floating point support.
            </p>

            <h3>Planned</h3>
            <p>
                Future designs in the "A" series (A2+) will use the same simple in-order
                principles as the A1, but increase vector parallelism in one or more of
                the following ways:
                <ul>
                    <li>Execute scalar instructions during vector operartions</li>
                    <li>Execute consecutive vector instructions in parallel (called "<a href="http://homepages.inf.ed.ac.uk/cgi/rni/comp-arch.pl?Vect/cray1-ch.html,Vect/cray1-ch-f.html,Vect/menu-cr1.html">chaining</a>" in Cray terms)</li>
                    <li>Duplicate execution units and process more than one vector element per cycle</li>
                </ul>
            </p>
            <p>
                Superscalar <a href="https://en.wikipedia.org/wiki/Tomasulo_algorithm">Tomasulo</a>-based
                implementations of the ISA are planned for the "B" series.
            </p>
        </div>

        <h2>Resources</h2>
        <div class="text-section">
                <p>
                Documentation and the MRISC32-A1 VHDL code is available at the GitHub
                repository: <a href="https://github.com/mbitsnbites/mrisc32">mbitsnbites/mrisc32</a>.
            </p>
            <p>
                The blog post "<a href="https://www.bitsnbites.eu/the-mrisc32-a-vector-first-cpu-design/">The MRISC32 – A vector first CPU design</a>"
                gives some information regarding the architectural features of the MRISC32 ISA.
            </p>
        </div>

        <h2>Software toolchains</h2>
        <div class="text-section">
            <p>
                There is currently an MRISC32 port of GNU binutils: <a href="https://github.com/mbitsnbites/binutils-mrisc32">mbitsnbites/binutils-mrisc32</a>.
                It provides:
                <ul>
                    <li>An assembler</li>
                    <li>A linker</li>
                    <li>Various elf32 tools (e.g. objdump)</li>
                </ul>
            </p>
            <p>
                Support for higher level languages is planned (via LLVM and/or GCC), but has
                not yet been implemented.
            </p>
        </div>

        <h2>Status</h2>
        <div class="text-section">
            <p>
                The MRSIC32 ISA and the MRISC32-A1 implementation are still in development.
                Several aspects such as exception handling and memory management are still
                undefined.
            </p>
        </div>

        <hr>
        <p class="footer">Copyright © 2018-2019 Marcus Geelnard</p>
    </body>
</html>
